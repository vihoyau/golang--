# Go面试真题

## Go基础类

### 1.与其他语言相比，使用Go有什么好处？

- 与其他作为实验室开始的语言不同，Go代码的设计更加务实。每个功能和语法决策都旨在让程序员的生活更轻松
- golang针对并发进行了优化，并且在规模上运行良好。
- 由于单一的标准代码格式，Golang通常被认为比其他语言更具有可读性
- 自动垃圾收集明显比java或Python更有效，因为它与程序同时执行。

### 2.Golang使用什么数据类型？

- golang使用以下类型：

	- Method、Boolean、Numeric、String、Array、Slice、Struct、Pointer、Function、Interface、Map、Channel

### 3.Go程序中的包是什么？

- 包（pkg）是Go工作区中包含Go源文件或其他包的目录。源文件中的每个函数、变量和类型都存储在链接包中。每个Go源文件都属于一个包，该包在文件顶部使用以下命令声明：packege <packagename>
- 可以使用以下方法导入和导出包以重用导出的函数或类型：import <packagename>
- Golang的标准包是fmt，其中包含格式化和打印功能，如Println()

### 4.Go支持什么形式的类型转换？将整数转换为浮点数。

- Go支持显式类型转换以满足其严格的类型要求
-  i := 55 // int
- j := 67.8 // float64
- sum := i + int(j) // j is converted to int

### 5.什么是Goroutine？你如何停止它？

- 一个Goroutine是一个函数或方法执行同时旁边其他任何go程采用了特殊的Goroutine 线程。Goroutine线程比标准线程更轻量级，大多数Golang程序同时使用数千个g、goroutine
- 要创建Goroutine,请go在函数声明之前添加关键字。

	- go f(x, y, z)

- 你可以通过向Goroutine发送一个信号通道来停止它。goroutine只能在被告知检查时响应信号，因此你需要再逻辑位置包含检查。
- package main
func main() {
  quit : = make(chan bool)
  go func() {
     for {
       select {
         case <- quit:
            return
         default:
       }  
     }
  }()
  quit <- true
}

### 6.如何在运行时检查变量类型？

- 类型开关是在运行时检查变量的最佳方式。类型开关按类型而不是值来评估变量。每个Switch至少包含一个case，用作条件语句，和一个 default case，如果没有一个case为真，则执行。

### 7.Go两个接口之间可以存在什么关系？

- 如果两个接口有相同的方法列表，那么他们就是等价的，可以相互赋值。如果接口A的方法列表是接口B的方法列表的自己，那么接口B可以赋值给接口A。接口查询是否成功，要在运行期才能够确定。
- 一个类型可以实现多个接口。多个类型可以实现同一个接口。

### 8.Go当中同步锁有什么特点？作用是什么

https://static001.geekbang.org/resource/image/44/b8/44c08abdd0aff633ca932fc89386ebb8.jpg?wh=3747*1972

- 当一个Goroutine（协程）获得了Mutex后，其他Goroutine（协程）就只能乖乖等待，除非该goroutine释放了该Mutex.RWMutex 在读锁 占用的情况下，会阻止写，但不阻止读RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占同步锁的作用是保证资源在使用时的独有性，不会因为并发而导致数据错乱，保证系统的稳定性。
- 一般情况下，struct有多个字段  我们会把mutex独立用空格分隔开使用。

	- // 线程安全的计数器类型
type Counter struct {
 CounterType int Name string mu 
 sync.Mutex count uint64
}

// 加1的方法，内部使用互斥锁保护
func (c *Counter) Incr() {
 c.mu.Lock()
 c.count++
 c.mu.Unlock()
}

- 谁申请谁释放

	- mutex容易出错的情况

		- Lock/unLock 不成对存在
		- Copy已使用的Mutex
		- 重入
		- 死锁

			- 互相等待
			- 只要破坏其中一种，即可解开

				- 互斥

					- 有的资源存在排他性。避免此事发生。

				- 持有和等待

					- goroutine持有一个资源，并在等待其他goroutine的资源的情况下。

				- 不可剥夺

					- 资源只能被持有它的goroutine释放。

				- 环路等待。

					- 避免形成环路的等待

### 9.Go语言当中Channel（通道）有什么特点, 需要注意什么？

- 执行Goroutine通信，不要采用内存共享，要通过channel通信的方式分享数据。
- Channel原理

	- 数据交流
	- 数据传递
	- 信号通知
	- 任务编排
	- 锁

- 基本用法

	- 只能接收

		- <- chan int

	- 只能发送

		- chan <- struct{}

	- 既能接收，也能发送

		- chan string

- Channel的实现原理

	- send
	- recv
	- close

- 使用channel容易犯的错误

	- 常见的错误是panic和Goroutine泄漏
	- 三种情况

		- close 为nil的chan
		- send 已经关闭的chan
		- close已经close的chan

- channel不是唯一的，使用并发原语更简单

	- 共享资源使用传统的并发原语
	- 复杂的任务编排和消息传递使用channel
	- 消息通知机制使用channel，除非只使用一个采用Cond。
	- 简单等待所有任务采用WaitGroup,也可以使用channel
	- 需要和select语句结合，使用Channel
	- 需要和超时结合的，使用Channel和Context

### 10.Go语言当中Channel缓冲有什么特点？

- 无缓冲的是同步的，有缓冲的是异步的。

### 11.Go语言中cap函数可以作用于哪些内容？

- array数组
- slice切片
- cahnnel通道

### 12.go convey是什么？一般用来做什么？

- go convey是一个支持golang的单元测试框架
- go convey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面。
- go convey提供了丰富的断言简化测试用例的编写。

### 13.go语言中new作用是什么？

- 使用new函数来分配空间
- new的是一个类型不是一个值
- 返回值是指向这个新分配的地址的指针

### 14.Go语言中make的作用是什么？

- make的作用是为slice、map、channel的初始化，然后返回引用make函数是内建函数，函数定义
- make和new不同，仅仅用于创建map、slice、chan，而且返回的是实例
- func make(type, size integerType) Type

### 15.Printf、Sprintf、FprintF都是格式化输出，有什么不同？

- Printf是标准输出，一般用于屏幕，也可以重定向。
- Sprintf是格式化字符串输出到指定的字符串中。
- Fprintf是格式化字符串输出到文件中。

### 16.Go语言当中数组和切片的区别是什么？

- 数组

	- 数组有固定长度，[3]int是两种不同的数组类型数组需要指定大小，不指定也会根据初始化的自动推算出大小，不可改变数组是通过值传递的。

- 切片

	- 切片可以改变长度切片是轻量级的数据结构，三个属性，指针，长度，容量不需要指定大小切片是地址传递（引用传递）可以通过数组来初始化，也可以通过内置函数make()来初始化，初始化的时候len=cap，然后进行扩容。

### 17.Go语言中值传递和地址传递（引用传递）如何运用？有什么区别？举例说明

- 1.值传递只会把参数的值复制一份放进对应的函数，两个变量的地址不同，不可相互修改。
- 2.地址传递（引用传递）会将变量本身传入对应的函数，在函数中可以对该变量进行值内容的修改。

### 18.Go语言当中数组和切片在传递的时候的区别是什么？

- 数组是值传递
- 切片是引用传递

### 19.Go语言是如何实现切片扩容的？

- apend的时候，自动扩容。

### 20.看下面代码的defer的执行顺序是什么？defer的作用和特点是什么？

- 作用

	- 加defer关键字即可。多个defer的执行顺序与声明反着来。
	- 无论中途遇到panic，还是正常return。都会执行。

- defer的常用场景

	- defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。
	- 通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。
	- 释放资源的defer应该直接跟在请求资源的语句后。

### 21.Golang Slice 的底层实现

- 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高。还可以通过索引获得数据，可以迭代以及垃圾回收优化。
- 切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。
- 切片对象非常小，是因为它是只有3个字段的数据结构：

	- 指向底层数组的指针
	- 切片的长度
	- 切片的容量

### 22.Golang Slice的扩容机制，有什么注意点？

- 首先判断，如果新申请容量大于2倍的旧容量，最终容量就是新申请的容量。
- 否则判断，如果旧切片的长度小于1024，则最终容量就是旧容量的两倍
- 否则判断，如果旧切片的长度大于等于1024，则最终容量从旧容量开始循环增加原来的1/4，直到最终容量大于等于新申请的容量。
- 如果最终容量计算值溢出，则最终容量就是新申请容量。

### 23.扩容前后的Slice是否相同？

- 情况一：

	- 原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同的地址slice

- 情况二：

	- 原来数组的容量已经达到了最大值，再想扩容，Go默认会开一片内存区域，把原来的值拷贝过来，然后再执行append()操作。这种情况下丝毫不影响原数组。
	- 要复制一个Slice，最好使用Copy函数

### 24.Golang的参数传递、引用类型

- Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。
- Golang的引用类型包括slice、map、channel。他们有复杂的内存结构，除了申请内存外，还需要初始化相关属性。内置函数new 计算类型大小，为其分配零值内存，返回指针。而make会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。

### 25.Golang Map 底层实现

- Golang中map的底层实现是一个散列表，因此实现map的过程实际上就是实现散列表的过程。在这个散列表中，主要出现的结构体有两个，一个叫hmap，一个叫bmap。

### 26.Golang Map如何扩容

- 装载因子：count/2^b
- 触发条件：

	- 1.装填因子是否大于6.5
	- 2.overflow bucket 是否太多

- 解决方法：

	- 双倍扩容：扩容采取了一种称为“渐进式”地方式，原有的key并不会一次性搬迁完毕，每次最多只会搬迁2个bucket
	- 等量扩容：重新排列，极端情况下，重新排列也解决不了，map成了链表，性能大大降低，此时哈希种子hash()的设置，可以降低此类极端场景的发生。

### 27.Golang Map 查找

- 哈希查找表，由一个Key通过哈希函数得到哈希值，64位系统中就生成一个64bit的哈希值，由这个哈希值将key对应到不同的桶（bucket）中，当有多个哈希映射到相同的桶中时，使用链表解决哈希冲突。key经过hash后共64位，根据hmap中B的值，计算它到底要落到哪个桶时，桶的数量为2^B,如B=5，那么用64位最后5位表示第几号桶，在用hash值的高8位确定在bucket中存储位置，当前bmap中的bucket未找到，则查询对应的overflow bucket，对应位置有数据则对比完整的哈希值，确定是否是要查找的数据。
- 如果两个不同的key落在同一个桶上，hash冲突使用链表法解决，遍历bucket中的key如果当前处于map进行了扩容，处于数据搬移状态，则优先从oldbuckets查找。

### 28.介绍一下Channel

- 不要通过共享内存来通信，而要通过通信来实现内存共享。Go的CSP并发模型，中文可以叫做通信顺序进程，是通过goroutine和channel来实现的。
- channel收发遵循先进先出FIFO，分为有缓存和无缓存，channel中大致有buffer（当缓冲区大小部位0-时，是个ring buffer）、sendx和recvx收发的位置、sendq、recvq当前channel因为缓冲区不足而阻塞的队列、使用双向链表存储、还有一个mutex锁控制并发、其他原属等。

### 29.Go语言的Channel特性？

- 给一个nil channel发送数据，造成永远阻塞
- 从一个nil channel接收数据，造成永远阻塞
- 给一个已经关闭的channel 发送数据，引起panic
- 从一个已经关闭的 channel接收数据，如果缓冲区中为空，则返回一个零值
- 无缓冲的channel同步的，而有缓冲的channel是非同步的。
- 关闭一个nil channel 将会发生 panic

### 30.Channel 的ring buffer 实现

- channel中使用了ring buffer(环形缓冲区)来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现FIFO 式的固定长度队列。
- 在channel中，ring buffer的实现如下

	- recvx sendx

## Go并发编程

### 0.如何解决资源的并发问题？

- 被保护起来的程序，叫做临界区。
- 使用Mutex互斥锁，限定临界区只能被一个线程资源拥有。
- Mutex是使用最广泛的同步原语
- 同步原语适用的场景

	- 共享资源。并发地读写资源，所以需要Mutex、RWMutex这种同步原语来保护。
	- 任务编排。需要Goroutine按照一定的规律执行，而goroutine之间有相互等待或者依赖的顺序关系。我们往往使用channel或waitGroup来实现。
	- 消息传递。goroutine的线程安全，往往采用Channel来实现。

- go tool compile trace -S 

	- 通过编译时，插入一些命令，检测并发读写，从而发现data race

### 1.Mutex几种状态

- mutex Locked 表示互斥锁的锁定状态
- mutexWoken 表示从正常模式被从唤醒
- mutexStarving 当前的互斥锁进入饥饿状态
- waitersCount 当前互斥锁上等待的Goroutine 个数

### 2.Mutex正常模式和饥饿模式

- 正常模式（非公平锁）

	- 正常模式下，所有等待锁的goroutine按照FIFO（先进先出）顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。
	- 新请求锁的Goroutine具有优势:

		- 它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的Goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的Goroutine会加入到等待队列的前面。如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁变为饥饿模式。

- 饥饿模式（公平锁）

	- 为了解决了等待G队列的长尾问题，饥饿模式下，直接由unlock把锁交给等待队列中排在第一位的G（队头），同时，饥饿模式下，新进来的G不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部，这样很好的解决了老的g一直抢不到锁的场景。
	- 饥饿模式的触发条件，当一个G等待锁时间超过1毫秒时，或者当前队列只剩下一个g的时候，Mutex切换到饥饿模式。

- 总结

	- 对于两种模式，正常模式下的性能是最好的，goroutine可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的一个平衡模式。

### 3.Mutex允许自旋的条件

- 1.锁已被占用，并且锁不处于饥饿模式。
- 2.积累的自旋次数小于最大自旋次数（active_spin=4）
- 3.cpu核数大于1
- 4.有空闲的P
- 5.当前Goroutine所挂载的P下，本地待运行队列为空。

### 4.RWMutex实现

- 通过记录readerCount读锁的数量来进行控制，当有一个写锁的时候，会将读锁数量设置为负数1<<30.目的是让新进入的读锁等待写锁之后释放通知读锁。同样的写锁也会等待之前的读锁都释放完毕，才会开始进行后续的操作。而等写锁释放之后，会将值重新加入1<<30，并通知刚才新进入的读锁(rw.readerSem),两者互相限制。

### 5.RWMutex注意事项

- 分析

	- 当写少读多，使用Mutex串行浪费资源。改用RWMutex可以提高并发性能。
	- Goroutine持有锁，就是排外锁，会导致其他Goroutine的读写被阻塞。
	- RWMutex就是用来解决reader-writer的问题。

- 什么是RWMutex？

	- RWMutex是一个标准的reader/writer互斥锁。
	- 5个方法

		- Lock/Unlock:写操作时调用的方法。

			- 当读操作，Lock就会阻塞

		- RLock/Runlock:读操作时调用的方法。

			- 当写操作，RLock就会阻塞

		- 返回一个Locker对象。

			- Lock返回一个RLock方法。
			- UnLock返回一个RUnLock方法。

- 陷阱

	- 不可复制。

		- 永远等待。

	- 重入导致死锁

		- 基于互斥锁实现的并发内部访问。
		- 运行时，容易检测出来。

	- 释放未加锁的RWMutex

- 流行中的

	- docker中

		- 错误把Lock当做RLock使用。

	- k8s

		- GetCPUSetOrDefault,释放pod的时候，引用的方法存在请求读锁。
		- 但是上下文代码也使用了锁。

- 特性

	- RWMutex是单写多读锁，该锁可以加多个读锁或者一个写锁。
	- 读锁占用的情况下会阻止写，不会阻止读，多个goroutine可以同时获取读锁。
	- 写锁会阻止其他goroutine（无论读和写）进来，整个锁由该Goroutine独占。
	- 适用于读多写少的场景。
	- RWMutex类型变量的零值是一个未锁定状态的互斥锁。
	- RWMutex在首次被使用之后就不能再拷贝。
	- RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发panic。
	- RWMutex 的一个写锁Lock去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的Goroutine将被阻塞直到解锁。
	- RWMutex的读锁不要用于递归调用，比较容易产生死锁。
	- RWMutex的锁定状态与特定的goroutine没有关联。一个goroutine可以RLock(Lock),另一个goroutine可以RWnlock
	- 死锁被解锁后，所有因操作锁定读锁而被阻塞的Goroutine会被唤醒，并都可以成功锁定读锁。
	- 读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的goroutine，其中等待时间最长的一个goroutine会被唤醒。

### 6.Cond是什么

- 限定容量的队列

	- 当阻塞时，利用等待/通知机制。实现阻塞和唤醒。

- 标准库的Cond

	- 应用等待某个条件的一组goroutine，等变为true，其中一个Goroutine或其他Goroutine被唤醒。
	- 某个条件相关，这个条件需要一组Goroutine协作共同实现。
	- 开发过程中，很少使用Cond，一般情况下使用channel来解决。

- Cond的基本用法

	- 实现

		- Signal

			- 允许使用唤醒一个等待Cond的goroutine

		- Broadcast

			- 允许所有Caller唤醒所有等待Cond的goroutine

		- Wait

			- 把Caller放入Cond阻塞，唤醒Signal或者BroadCast

	- 知名使用

		- 同样的场景我们会使用其他同步原语来替代。例如:channel同样具有唤醒、通知。而不是使用Cond的wait/notify机制。
		- 对于简单的wait/notify场景，可以使用waitGroup来实现。而且不容易出错

- 特性

	- Cond实现了一种条件变量，可以使用在多个Reader等待共享资源ready的场景（如果只有已一个读写，一个锁或者channel就可以搞定了）
	- 每个Cond都会关联一个Lock（*sync.Mutex or *sync.RWMutex），当修改条件或者调用Wait方法时，必须加锁，保护condition

### 7.Broadcast和Signal区别

- Braodcast会唤醒所有等待的c的Goroutine
- Signal只唤醒1个等待c的Goroutine

	- 调用Signal可以加锁也可以不加锁

### 8.Cond中Wait使用

- Wait()会自动释放c.L，并挂起调用者的Goroutine。之后恢复执行，Wait()会在返回时对c.L加锁
- func (c *Cond) Wait()

### 9.WaitGroup用法

- 作用

	- 解决一个并发-等待问题

		- 现在有一个GoroutineA在等待其他goroutine完成任务，如果没有全部完成，那么goroutineA就会阻塞在检查点，直到所有Goroutine完成。

- 基本用法

  package main
  
  import (
      "fmt"
      "sync"
      "time"
  )
  
  // 线程安全的计数器
  type Counter struct {
      mu  sync.Mutex
      count uint64
  }
  
  // 对计数值加一
  func (c *Counter) Incr() {
      c.mu.Lock()
      defer c.mu.Unlock()
      c.count++    
  }
  
  // 获取当前的计数值
  func (c *Counter) Count() uint64 {
      c.mu.Lock()
      defer c.mu.Unlock()
      return c.count
  }
  
  // sleep 睡眠1秒 ，然后计数加1、
  func worker(c *Counter, wg *sync.WaitGroup){
      defer wg.Done()
      time.Sleep(time.Second)
      c.Incr()
  }
  
  func main() {
      var counter Counter
      var wg sync.WaitGroup
      wg.Add(10)
      for i := 0; i < 10; i++ {
          go worker(&counter, &wg)
      }
      // 检查点，等待goroutine任务完成
      wg.Wait()
      // 输出当前计数器的值
      fmt.Println(counter.count)
  }

	- func (wg *waitGroup) Add(delate int)
func (wg *waitGroup) Done()
func (wg *waitGroup) Wait()

		- Add 用来计数值
		- Done用来减1，其实就是Add(-1)
		- Wait 调用这个Goroutine一直阻塞，直到waitGroup计数为0

	- 实现

		- 去看源码

- 需要注意的地方

	- 场景1：计数器的值为-1

		- 负值就会panic
		- 1.传入Add(负值)，要保障计数器>= 0
		- 2.调用Done方法过多，超过了waitGroup的计数值
		- 预先计算好Add次数，再给相同的Done

	- 场景2：不期望的Add时机

		- 等所有Add调用之后，再调用Wait，否则会panic
		- 另外的法子，再调用go之前Add

	- 场景3：前一个Wait还没结束就重用WaitGroup

		- waitGroup是可以重用的
		- 需要等上一轮go并发完成后，再重用。否则，panic

	- 辅助vet检查。静态检测

- 流行的Go项目遇到的坑

	- 违反了wg复制规则
	- K8s忘记在wait之前增加计数

- 避免错误发生

	- 不重用waitGroup
	- 保证所有Add方法都在wait之前
	- 不做多余的Done调用
	- 不遗漏Done方法调用

- 使用方法

	- main协程通过调用wg.Add(delta int)设置worker协程的个数，然后创建worker协程
	- worker协程执行结束之后，都要调用wg.Done()
	- main协程调用wg.Wait()且被block，直到所有worker协程全部执行结束后返回。

### 10.WaitGroup实现原理

- WaitGroup主要维护了2个计数器，一个是请求计数器v，一个是等待计数器w，二者组成一个64bit值，请求计数器占高32bit，等待计数器占低32bit。
- 时通过信号量唤醒wait()

### 11.什么是sync.Once

- 为什么使用Once？

	- Once执行且仅仅执行一次动作，常常用于单例对象的初始化场景

- 一般单例的场景有性能问题

  package main
  
  import (
    "net"
    "sync"
    "time"
  )
  
  // 使用互斥锁保证线程(goroutine)安全
  var connMu sync.Mutex
  var conn net.Conn
  
  func getConn() net.Conn {
    connMu.Lock()
    defer connMu.Unlock()
  
    // 返回已创建好的连接
    if conn != nil {
      return conn
    }
  
    // 创建连接
    conn, _ = net.DialTimeout("tcp", "baidu.com:80", 10*time.Second)
    return conn
  }
  
  // 使用连接
  func main() {
    conn := getConn()
    if conn == nil {
      panic("conn is nil")
    }
  }

	- 每次都要得竞争锁才能使用此资源

- 使用场景

	- sync.Once只暴露一个方法Do，你可以多次调用Do方法，但是只有使用一次Do方法时，f参数才会执行。这里的f是一个无参数无返回值的函数。

		- func (o *Once) Do(f func())

	- 常常用来初始化单例资源，或者并发只需要一次的共享资源、或测试需要一次的资源。

	  var addr = "baidu.com"
	  
	    var conn net.Conn
	    var err error
	  
	    once.Do(func() {
	      conn, err = net.Dial("tcp", addr)
	    })

- 如何实现一个Once？

	- 有人认为最多使用atomic原子操作这个flag

	  type Once struct {
	    done uint32
	  }
	  
	  func (o *Once) Do(f func()) {
	    if !atomic.CompareAndSwapUint32(&o.done, 0, 1) {
	      return
	    }
	    f()
	  }

	- 一个正确的Once实现使用一个互斥锁，这样的初始化的时候如果有并发的goroutine就会进入doSlow

		- 利用双检测机制

		  type Once struct {
		    done uint32
		    m  Mutex
		  }
		  
		  func (o *Once) Do(f func()) {
		    if atomic.LoadUint32(&o.done) == 0 {
		      o.doSlow(f)
		    }
		  }
		  
		  
		  func (o *Once) doSlow(f func()) {
		    o.m.Lock()
		    defer o.m.Unlock()
		    // 双检查
		    if o.done == 0 {
		      defer atomic.StoreUint32(&o.done, 1)
		      f()
		    }
		  }

- 使用Once可能出现的错误

	- 死锁：递归Do死锁
	- 未初始化，如果f被panic

	  // Once 是一个扩展的sync.Once类型，提供了一个Done方法
	  type Once struct {
	    sync.Once
	  }
	  
	  // Done 返回此Once是否执行过
	  // 如果执行过则返回true
	  // 如果没有执行过或者正在执行，返回false
	  func (o *Once) Done() bool {
	    return atomic.LoadUint32((*uint32)(unsafe.Pointer(&o.Once))) == 1
	  }
	  
	  func main() {
	    var flag Once
	    fmt.Println(flag.Done()) //false
	  
	    flag.Do(func() {
	      time.Sleep(time.Second)
	    })
	  
	    fmt.Println(flag.Done()) //true
	  }

		- 一般使用前做检查可以规避这个问题，go vet

### 12.什么操作叫做原子操作

- atomic要保证原子操作，一定要使用这几种方法
- 原始操作的基础知识

	- sync/atomic实现了同步算法的原子的内存操作原语。
	- CPU提供了基础的原子操作

		- 不同的CPU架构甚至不同的版本提供的原子操作的指令不同。要用一种编程语言支持不同架构的原子操作有一定的难度。

	- 原子操作的应用场景

		- 使用atomic实现自己基础的并发原语
		- atomic是实现lock-free的数据结构的基石

	- atomic提供的方法

		- 操作的一个对象是一个地址，把可寻址的变量的地址作为参数传递给方法。不是值。
		- Add
		- CAS
		- SWAP
		- Load
		- Store
		- Value类型

	- 使用atomic实现Lock-Free queue

- 特性

	- 一个或者多个操作在CPU执行过程中不被中断的特性，称为原子性。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。
	- 而在现实世界中，CPU不可能不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣称套门又有了“不可分割”的原子性。
	- 在Go中，一条普通的赋值语句其实不是一个原子操作。例如，在32位机器上写int64类型的变量就会有中间状态，因为他会被拆成两次写操作（MOV）--写低32位和写高32位

### 13.原子操作和锁的区别

- 原子操作由底层硬件支持，而锁则由操作系统的调度器实现。锁应当用来保护一些逻辑，对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算多核的优势，如果要更新的是一个复合对象，则应当使用atomic.Value封装好的实现。

### 14.什么是CAS

- 全称为Compare And Swap。比较交换。
- 是一条CPU的原子指令，其作用是让CPU先就进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在intel的CPU中，使用的cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。
- CAS操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。基于这样的原理，CAS操作即使没锁，也可以发现其他线程对于当前线程的干扰。

### 15.sync.Pool有什么用

- 对于很多需要分配、回收内存的地方，sync.Pool是一个很好的选择。频繁地分配、回收内存会给GC带来一定的负担，严重的时候会引起CPU的毛刺，而sync.Pool可以暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻GC的压力，提升系统的性能。
- 性能提升大杀器

	- Go是自动垃圾回收的编程语言，采用三色并发标记对象回收算法。
	- 如果你想Go语言开发一个高性能的应用程序的话，你必须考虑垃圾回收带来的影响。
	- 池化的对象可能被垃圾回收掉。
	- sync.Pool

		- 使用方法

			- New、Get、Put

		- 实现原理

			- 每次GC都会回收创建的对象

				- 对象太多，导致Get命中率下降。不得不新建一些新的对象。

			- 底层实现使用Mutex，对这个锁并发竞争激烈的时候，会导致性能下降。

				- Go对Pool的优化就是避免使用锁，同时将加锁的queue改成lock-free的实现。给即将移除的元素再次“重活”的可能。

		- 遇到的坑

			- 内存泄漏

				- 大的Buffer没有被回收，而是占用很大的内存。

		- 连接池

			- 很少使用sync.Pool去池化连接对象

				- 因为我们需要长久的连接，sync.Pool会清除这些对象。

			- 标准库的http client池

				- TCP池

			- 数据库连接池
			- Memcache 连接池
			- worker Pool

### 16.Context信息穿透上下文

- 功能

	- 上下文信息传递，比如http请求，在处理请求链路信息。
	- 控制Goroutine的运行
	- 超时控制的方法调用
	- 可以取消的方法调用

- 基本使用方法

	- 一般使用Context会把这个参数放在第一个位置
	- 从来不把nil当成Context
	- 做函数之间的上下文传递
	- key的类型不应该是字符串类型

- 创建特殊用途context方法

	- WithValue
	- WithCancel
	- WithTimeout
	- WithDealine

- 总结

	- Context用来cancel 掉goroutine是最常用的用法
	- 用于超时处理，大概率是为了避免客户端过长的等待

## Go Runtime

### 1.Goroutine定义

- Goroutine是一个与其他goroutine并行运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine在同一个用户地址空间里并行独立执行functions，channels则用于Goroutines间的通信和同步访问控制。

### 2.GMP指的是什么

- G(Goroutine):我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着上下文信息。
- M(Machine)：对内核线程的封装，数量对应真实的CPU数(真正干活的对象)
- P(Processor): 即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数。

### 3.1.0之前GM调度模型

- 调度器把G都分配到M上，不同的G在不同的M并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源是全局的，就会因为资源竞争照成很多性能损耗。

	- 1.单一全局互斥锁(Sched.Lock)和集中状态存储
	- 2.Goroutine传递问题（M经常在M之间传递“可运行”的goroutine）
	- 3.每个M做内存缓存，导致内存占用过高，数据局部性较差
	- 4.频繁syscall调用，导致严重的线程阻塞/解锁，加剧额外的性能损耗。

- 为了解决这一个问题go从1.1版本引入，在运行时系统的时候加入P对象，让P去管理这个G对象，M想要运行G，必须绑定P，才能运行P所管理的G

### 4.GMP调度流程

- 自己画一遍
- 调度原理

	- Goroutine调度器

		- 一个Go程，对于系统来说是用户级程序
		- 可是在操作系统上，竞争的CPU是物理CPU，而Go程竞争的CPU是什么CPU呢？

			- 竞争的CPU是操作系统线程。
			- 这样的话，goroutine调度器就明确了。

				- 将goroutine按照一定的算法放到不同的操作系统的线程上。

		- 为了更好地控制活跃的M的数量，调度器引入了GOMAXPROCESS变量来表示调度器可见的“处理器”的数量。

	- GM模式

		- 缺点

			- 限制了Go程序的伸缩性，尤其是高并发的场景下。

		- 问题体现

			- 单一全局互斥锁和集中状态存储的存在。创建、重新调度，都要上锁。
			- Goroutine传递问题，M与M之间的传递，损耗性能，延迟。
			- 每个M都做内存缓存，导致内存过高，数据局部性较差
			- 用于系统调用(syscall)频繁，导致线程阻塞，解除阻塞。带来性能损耗。

		- 有人讲，任何计算机科学问题，都可以增加一个中间层来解决。

	- GPM模式

		- P（逻辑processer）

			- 真正的CPU是M
			- 在G的眼里只有P

		- 1.4版本，对非协作的抢占式调度的支持。是基于信号的。
		- GPM

			- G代表Goroutine。任务函数、执行、状态
			- P代表逻辑，P的数量代表系统内最大可并行的G。P最大的作用，拥有G的链表、对象队列、一些缓存和状态。
			- M代表真正的计算资源。
			- G被抢占调度

				- channel阻塞或网络IO的调度
				- 系统调用阻塞情况下的调度

			- 如果一个G任务10ms，系统任务它太慢而发起抢占式调度的请求。

### 5.GMP中work stealing 机制

- 存在P本地队列或者是全局队列。P此时去唤醒一个M。P继续执行它的执行序。M寻找是否有空闲的P，如果有则将该G对象移动到它本身。接下来M执行一个调度循环(调用G对象 -> 执行 -> 清理线程 -> 继续找新的Goroutine执行。)

### 6.GMP中hand off 机制

- 处理大整数的算法
- 如果大整数超过某个阈值，就将一部分交给其他函数处理。
- 提高处理大整数的效率。

### 7.协程式的抢占式调度

- 在1.14版本之前，程序只能依靠Goroutine主动让出CPU资源才能触发调度，存在问题。

	- 某些Goroutine可以长时间占用线程，造成其他Goroutine的饥饿
	- 垃圾回收需要暂停整个程序(Stop-the-world,STW),最长可能需要几分钟的时间，导致整个程序无法工作。

### 8.基于信号的抢占式调度

- 在任何情况下，Go运行时并行执行（注意，不是并发）的goroutine数量是小于等于P的数量的。
- 为了提高系统的性能，P的数量肯定不是越小越好，所以官方默认值就是CPU的核心数，设置的过小的花，如果一个持有P的M，由于P当前执行的G调用了syscall而导致M被阻塞，那么此时关键点：Go的调度器是迟钝的，它很可能什么都没做，直到M阻塞了相当长时间以后，才会发现有一个P/M被syscall阻塞了。

	- 然后，才会用空闲的M来抢这个P。

- 通过sysmon监控实现的抢占式调度，最快在20us，最慢在10-20ms才会发现有一个M持有P并阻塞了。
- 操作系统再1ms内可以完成很多次线程调度（一般情况下1ms可以完成几十次线程调度），Go发起IO/syscall的时候执行该G的M会阻塞然后被OS调度走，P什么也不干，sysmon最慢要10-20ms才能发现这个阻塞，说不定那时候阻塞已经借宿了，宝贵的P资源就这么被阻塞的M浪费掉了。

### 9.GMP调度过程中存在哪些阻塞

- I/O, select
- block on syscall
- channel
- 等待锁
- runtime.Gosched()

### 10.sysmon有什么作用

- sysmon也叫监控线程，变动的周期性检查

	- 释放闲置超过5分钟的span物理内存。
	- 如果超过2分钟没有垃圾回收，强制执行。
	- 将长时间未处理的netpoll添加到全局队列。
	- 向长时间运行的G任务发出抢占调度（超过10ms的g，会进行retake）；
	- 收回因syscall长时间阻塞的P；

### 11.三色标记原理

- pprof
- sync.Pool有比较好的优化效果
- STW

	- STW是“Stop the World”的缩写，在Go语言中指的是一种停止全局操作的方式。它通常用于在垃圾收集过程中暂停所有的线程，以便收集垃圾。它的主要作用是确保垃圾收集的正确性，以及防止在垃圾收集过程中由于线程并发造成的问题。

### 12.插入写屏障

- golang的回收没有混合屏障之前，一直是插入写屏障，由于栈赋值没有hook的原因，所以栈中没有启用写屏障，所以有STW。
- golang的解决方法是：只是需要再结束时启动STW来重新扫描栈。这个自然就会导致整个进程的赋值器卡顿，所以后面golang是引用混合写屏障解决这个问题。混合写屏障之后，就没有STW。

### 13.删除写屏障

- golang没有这一步，golang的内存写屏障是由插入写屏障到混合写屏障过渡的。
- 简单介绍一下，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

### 14.写屏障

- Go在进行三色标记的时候并没有STW，也就是说，此时的对象还是可以进行修改。

### 15.混合写屏障

- 混合写屏障继承了插入写屏障的优点，起始无需STW打快照，直接并发扫描垃圾即可。
- 混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后STW的重新扫描栈；
- 混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是GC过程全程无STW
- 混合写屏障扫描栈虽然没有STW，但是扫描某个一个具体的栈的时候，还是要停止这个goroutine赋值器的工作的哈。

### 16.GC触发时机

- 主动触发：runtime.GC
- 被动触发

	- 当程序占用内存达到一定量，超过规定的阈值时自动触发
	- 对象不再被使用则触发
	- 某个对象内存达到一定阈值

### 17.Go语言中GC的流程是什么？

- 以STW为界限，可以将GC划分为五个阶段：

	- 阶段说明赋值器状态GCMark标记准备阶段，为并发标记做准备工作，启动写屏障STWGCMark扫描标记阶段，与赋值器并发执行，写屏障开启并发GCMarkTermination标记终止阶段，保证一个周期内标记任务完成，停止写屏障STWGoff内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭并发GCoff内存归还阶段，将过多的内存归还给操作系统，写屏障关闭开发。

- 流程

	- 扫描内存中的所有对象，查找不再使用的对象
	- 分配新的内存，用来存储不再使用的对象
	- 将不再使用的对象，移动到新内存中
	- 标记所有不再使用的对象
	- 回收所有被标记的对象使用的内存

### 18.GC如何调优

- go tool pprof 和 go tool trace 等工具

	- 控制内存分配的速度，限制goroutine的数量，从而提高赋值器对CPU的利用率
	- 减少并服用内存，例如使用sync.Pool来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
	- 需要时，增大GOGC的值，降低GC的运行频率

### 19.如何进行性能排查？

- 使用性能监控工具，例如：perf、pprof，来监控性能，从而了解程序中性能的瓶颈

	- go pprof应该如何使用，有哪些信息

		- import "runtime/pprof"

// 在程序中添加以下代码，即可输出内存使用情况
f, err := os.Create("mem.prof")
if err != nil {
    log.Fatal(err)
}
pprof.WriteHeapProfile(f)
f.Close()

		- import "runtime/pprof"

// 在程序中添加以下代码，即可输出CPU使用情况
f, err := os.Create("cpu.prof")
if err != nil {
    log.Fatal(err)
}
pprof.StartCPUProfile(f)
defer pprof.StopCPUProfile()


- 对程序进行性能测试。通过一些测试用例可以看出。例如压测工具wrk，可以知道并发的响应时间。例如单元测试convey框架，可以适当并发出高的性能。
- 分析程序的性能瓶颈。通过看一些grafna监控可以了解到。
- 优化程序的性能

### 20.如何对go语言进行调试?

- fmt函数输出
- 使用log包
- 使用断言函数assert.true()
- 使用调试器

### 21.go的并发机制是什么？

- goroutine和channel来实现
- channel是用来goroutine的通信和同步

### 22.go语言使用grpc需要注意哪些？

- grpc作为数据交互角色，需要编写proto配置文件。
- grpc在使用TLS加密时，需要预先生成证书，并在客户端和服务端使用。
- 在使用streaming在RPC中，需要注意数据量的同步和处理，避免出现缓冲区溢出，或数据丢失。
- 在使用rpc时，需要注意服务端的负载均衡和客户端重试策略。避免请求超时和连接失败。
- 在使用连接池中，需要注意连接的生命周期和状态监控，避免出现连接泄漏和连接问题。

## 微服务

### 1.你对微服务有何了解？

- 当前互联网最先进的业务架构解决方案，能更好地适应移动互联网迭代的需求。
- 什么是服务化?

	- 解决单体服务的膨胀，团队开发耦合度高、协作效率低下的问题。

- 什么是微服务？

	- 服务拆分粒度更小。
	- 服务独立部署
	- 服务独立维护
	- 服务治理能力要求高

- 什么时候进行服务化拆分？

	- 根据业务场景

- 服务化拆分的两种姿势？

	- 纵向拆分

		- 根据关系程度而拆分

	- 横向拆分

		- 公共且独立

- 服务拆分的几个条件

	- 服务如何定义

		- 协议：RPC还是HTTp

	- 如何发布和订阅

		- 注册中心

	- 服务如何监控

		- 我们最关心的是QPS、可用性
		- 做好业务埋点、数据收集、数据处理
		- skywalking

	- 服务如何治理

		- 熔断

	- 故障如何定位

		- 对服务请求进行标记，进行传递，以便串连所有的定位

- 初探微服务架构

	- Swagger
	- 注册中心
	- 服务框架
	- 服务监控

		- 指标收集
		- 数据处理
		- 数据展示

	- 服务追踪

		- requestid

	- 服务治理

		- 单机故障
		- 单IDC故障
		- 依赖服务不可用

- 如何发布引用微服务？

	- 配置
	- IDL文件

- 如何注册和发现服务？

	- RPC Server Client
	- 集群部署Zookerper
	- 白名单机制

- 如何实现RPC远程服务调用？

	- 客户端和服务端如何建立连接？

		- TCP三次握手来建立
		- socket通信

			- 服务器监听
			- 客户端请求
			- 服务端连接确认
			- 数据传输

	- 服务端如何处理请求

		- 同步阻塞方式
		- 同步非阻塞方式
		- 异步非阻塞方式

	- 数据该如何序列化和反序列化？

		- PB/thrift

	- 如何监控微服务调用

		- 监控对象
		- 监控指标

			- 请求量
			- 响应时间
			- 错误率

		- 监控维度

			- 全局监控

		- 监控系统

			- 数据采集
			- 数据传输
			- 数据处理
			- 数据展示

### 2.说说微服务架构的优势

- 独立开发
- 独立部署
- 故障隔离
- 混合技术栈
- 粒度缩放

### 3.微服务有哪些特点？

- 解耦
- 组件化
- 业务能力
- 自治
- 持续交付
- 责任
- 分散治理
- 敏捷

### 4.设计微服务的最佳实践是什么？

### 5.微服务架构如何运作？

- 微服务架构具有以下组件：

	- 客户端
	- 身份提供商
	- API网关
	- 静态内容
	- 管理
	- 服务发现
	- 内容交付网络
	- 远程服务

### 6.微服务架构的优缺点是什么？

- 优点

	- 自由使用不同的技术
	- 每个微服务都侧重于单一功能
	- 支持单个可部署单元
	- 允许经常发布软件
	- 确保每项服务的安全性
	- 多个服务是并行开发和部署的

- 缺点

	- 增加故障排查挑战
	- 由于远程呼叫而增加延迟
	- 增加了配置和其他操作的工作量
	- 难以保持交易安全
	- 艰难地跨越各种便捷跟踪数据
	- 难以在服务之间进行编码

### 7.单片，SOA和微服务架构有什么区别？

- 单片架构类似于大容器，组件装在一起并紧密封装
- 一个面向服务的架构是一种互相通信服务的集合。
- 微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。

### 8.在使用微服务架构时，您面临哪些挑战？

- 自动化组件
- 易感性
- 配置管理
- 调试

### 9.SOA和微服务架构之间的主要区别是什么？

- SOA

	- 多线程

		- 带来很多IO开销

	- 可重用
	- 多种消息协议

- 微服务

	- 专注于解耦
	- 单线程通常使用事件循环功能进行非锁定IO

### 10.微服务有什么特点？

### 11.什么是领域驱动设计？

### 12。为什么需要域驱动设计（DDD）？

### 13.什么是无所不在的语言？

### 14.什么是凝聚力?

- 模块内部元素所属的程度被认为是凝聚力。

### 15.什么是耦合？

- 组件之间依赖关系强度的度量被认为是耦合。一个好的设计总是被认为具有高内聚力和低耦合性。

### 16.什么是REST/RESTful以及它的用途是什么？

- Web的一种帮助通信的架构风格。

### 17.什么是不同类型的微服务测试？

- 底层

	- 单元测试

- 中间层

	- 压测

- 顶层

## Redis

### 1.什么是Redis？

- 支持了字符串、有序集合、集合、列表等类型。提供了丰富的特性，消息订阅、事务处理。
- key-value有三个特点

	- 支持持久化，可以将内存中的数据保存到磁盘中，重启时可以再次加载进行使用。
	- 不仅仅支持key-value类型，还支持list、set、zset、hash等数据结构的存储
	- redis支持数据备份，即master-slave模式的数据备份。

- Redis优势

	- 性能极高-Redis能读的速度是110000次/s，写的速度是81000次/s
	- 丰富的数据类型-Redis支持二进制案例的Strings，Lists，Hashes，Sets及Ordered Sets数据类型操作
	- 原子，Redis的所有操作都是原子性的，意思就是要么成功执行，要么失败完全不执行。单个操作就是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。

- Redis与其他key-value存储有什么不同？

	- 支持多种数据结构，除了string，还有list、set、zset等。
	- Redis在内存中可以持久化到磁盘中，所以在高速读写时需要权衡内存，因为数据量不能大于硬盘内存。
	- Redis 提供了丰富的数据类型：除了普通的字符串类型外，Redis 还提供了多种其他数据类型，如列表、集合、有序集合等，可以满足更多的使用场景。
Redis 提供了多种持久化方式：Redis 提供了多种持久化方式，可以将数据保存到磁盘上，避免数据丢失。
Redis 支持多种数据备份方式：Redis 支持多种数据备份方式，可以将数据备份到其他 Redis 服务器上，实现数据的冗余备份。
Redis 支持数据的多种操作：Redis 支持对数据进行多种操作，如排序、聚合、计数等，方便您进行复杂的数据处理。
因此，Redis 可以说是一种高性能、功能强大、易于使用的 key-value 存储系统，可以满足各种复杂的使用场景。

### 2.Reids的数据类型？

- 高级用法：HyperLogLog、Geo、Pub/Sub.
- Redis Module

	- BloomFilter,RedisSearch,Redis-ML

### 3.使用Redis有哪些好处?

- 速度快，因为数据存在内存中，类似与HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
- 支持丰富数据类型，支持string，list，set，Zset，hash等。
- 支持事务。
- 丰富的特性：缓存、消息、按key设置过期时间，过期后将会自动删除。

### 4.Redis相比Memcached有哪些优势？

- Memcached只有字符串。Redis类型多。
- Redis比Memcached快
- Redis可以持久化

### 5.Memcache与Redis的区别都有哪些？

- memcache全部存在内存，断点会丢失。Redis是有部分存在硬盘上的，可以保证数据的持久性。
- 底层模型不同，通信协议不同。Redis自己构建VM机制，会浪费一定的时间去移动和请求。

### 6.Redis是单进程单线程的？

- 利用队列技术将并发访问变成串行访问，消除了传统数据库串行控制的开销。

### 7.一个字符串类型的值能存储最大容量是多少？

- 512M

### 8.Redis的持久化机制是什么？各自有点？

- 两种持久化机制RDB和AOF机制

	- RDB

		- 优点

			- 只有一个文件dump.rdb，方便持久化
			- 容灾性好，一个文件可以保存到安全的磁盘
			- 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以在IO最大化。使用单独子进程来持久化。
			- 处理数据集大时，比AOF的启动效率更高。

		- 缺点

			- 数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会导致数据丢失。所以场景是要求不严谨的时候使用。

	- AOF

		- 优点

			- 数据安全
			- append文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。
			- rewrite模式，文件过大时会对命令进行合并操作，可以删除其中的某些命令。（比如误删操作）

		- 缺点

			- AOF文件比RDB文件大，且恢复速度慢。
			- 数据集大的时候，比rdb启动效率低。

### 9.Redis常见性能问题和解决方案：

- 1.Master最好不要写内存快照，如果Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务
- 2.如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步
- 3.为了主从复制的速度和连续的稳定性，Master和Slave最好在同一个局域网。
- 4.尽量避免在压力很大的主库上增加。
- 5.主从复制不要用图壮结构，用单向链表结构更为稳定，即：Master<- Slavel <- Slave2 <- Slave3...这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。

### 10.Redis过期键的删除策略？

- 1.定时删除：在设置键的过期时间的同时，创建一个定时器timer。让定时器在键的过期时间来临时，立即执行对键的删除操作。
- 2.惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键。
- 3.定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

### 11.Redis的回收策略（淘汰策略）？

- Redis的回收策略可以是多种多样的，但最常见的方法是使用LRU（Least Recently Used，最近最少使用）算法。该算法会把最近最少使用的数据淘汰出缓存，以便为新数据腾出空间。此外，Redis还支持其他的回收策略，例如LFU（Least Frequently Used，最近最不常使用）和FIFO（First In First Out，先进先出）。
- 使用策略规则

	- 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lr
	- 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random

### 12.为什么Redis需要把所有数据放到内存中？

- Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。
- 所以redis具有快速和数据持久化特征。
- 如果不将数据放在内存中，磁盘IO速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。
- 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能插入新值。

### 13.Redis的同步机制了解么？

- Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### 14.Pipeline有什么好处，为什么要用pipeline?

- 可以将多次IO往返的时间缩减为一次，前提是pieline执行的命令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

### 15.是否使用过redis集群，集群的原理是什么？

- Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
- Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
- Redis 集群是一种在多台 Redis 服务器上分布式存储数据的方式。它通过将数据分片存储在多个 Redis 服务器上，并通过一个调度器自动将读写请求分配到正确的 Redis 服务器上，实现了分布式存储。这样，通过 Redis 集群可以提高 Redis 的性能和可用性，并且可以更好地处理大量的数据。

### 16.Redis集群方案什么情况下会导致整个集群不可用?

- 主节点宕机
- 使用redis Cluster和Sentinel可以避免

### 17.Redis支持的Java客户端都有哪些？官方推荐用哪个？

- Redisson、Jedis、Lettuce等等，官方推荐使用Redisson

### 18.Jedis与Redisson对比有什么优缺点？

- Jedis不支持排序、事务、管道、分区等Redis特性。

### 19.Redis如何设置密码及验证密码？

- 设置密码：config set requirepass 123456
- 授权密码： auth 123456

### 20.说说Redis哈希槽的概念？

- redis集群没有使用一致性hash，而是引入哈希槽的概念。Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定防止哪个槽，集群的每个节点负责一部分hahs槽。

### 21.Redis集群的主从复制模型是怎么样的？

- 为了实在部分节点失败或者大部分节点无法通信的情况下集群仍可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品

### 22.Redis集群会有写操作丢失吗？为什么？

- Redis并不能保证数据的强一致性，这意味着这在实际中集群在特定的条件下可能丢失写操作。

### 23.Redis集群之间是如何复制的？

- 异步复制。

### 24.Redis集群最大节点个数是多少？

- 16384个

### 25.Redis集群如何选择数据库？

- Redis集群目前无法做数据库选择，默认在0数据库。

### 26.怎么测试Redis的连通性？

- 使用Ping

### 27.怎么理解Redis事务？

- 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序低执行。事务在执行的过程中，不会被其他客户端发来的命令请求打断。
- 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

### 28.Redis事务相关的命令有哪几个？

- MULTI、EXEC、DISCARD、WATCH

### 29.Redis key 的过期时间和永久有效分别怎么设置？

- EXPIRE和PRESIST命令

### 30.Redis如何做内存优化？

- Redis 是一个开源的内存数据库，它可以用来做很多事情，包括作为缓存和消息队列系统。要对 Redis 进行优化，有几个方面需要考虑。
- 首先，你可以通过指定内存限制来控制 Redis 的内存使用量。这样可以避免 Redis 占用过多的内存，从而提高系统的性能。
- 其次，你可以使用 Redis 的持久化功能来将数据保存到硬盘上。这样，即使 Redis 宕机或重启，数据也不会丢失。
- 此外，你还可以使用 Redis 的集群功能，将数据分布在多个节点上。这样可以提高 Redis 的读写性能，并减少单个节点的负载。
- 总之，要对 Redis 进行优化，需要综合考虑多个因素，根据实际情况进行调整

### 31.Redis回收进程如何工作的？

- Redis会检查内存是否超过maxmemory限制，根据设定好的策略进行回收。

### 32.都渔鸥哪些办法可以降低Redis的内存使用情况呢？

- 可以好好利用Hash,list,sorted,set等集合类型。

### 33.Redis的内存用完了会发生什么？

- 返回错误信息。
- 可以使用Redis缓存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。

### 34.一个Redis实例最多能存放多少的Keys？List、Set、Sorted Set他们最多能存放多少元素？

- 每个数据结构最多放232个keys
- 实际上是2亿个keys。
- redis的极限是系统中可用的内存值

### 35.MySQL里有2000w数据，Redis中只存20w的数据，如何保证redis中的数据都是热点数据？Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

- 随机淘汰、过期使用最少的淘汰等。

### 36.Redis最适合的场景？

- 会话缓存(Session Cache)
- 全页缓存（FPC）
- 队列
- 发布/订阅

	- 用Redis来做发布/订阅功能来建立聊天系统。

### 37.假如Redis里面有1亿个key，其中与10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来。

- Scan命令进行扫描。
- 单线程的，会阻塞一段时间。

### 38.如果有大量的key需要设置同一时间过期，一般需要注意什么？

- 加个随机值，使得过期时间分散一些。

### 39.使用过redis做异步队列么，你是怎么用的？

- rpush生产信息，lpop消费信息。如果lpop没有消息的时候，要适当sleep一会再重试。
- 可不可以不用sleep

	- list航海油一个指令blpop，在没有消息的时候，它会阻塞，直到消息到来。

- 能不能生成一次消费多次呢？

	- 使用pub/sub主题订阅者模式，可以实现1：N的消息队列

- pub/sub有什么缺点？

	- 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列RabbitMQ等。

- Redis如何实现延时队列？

	- 使用sortedset，那时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

### 40.使用过Redis分布式锁么，它是什么回事？

- 先拿setNx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
- 如何避免setnx之后，执行expire之前，进程意外crash或者要重启维护了，那会怎么样？

	- set命令有非常复杂的参数，setnx和expire合成一条指令来用的。

## LINUX

### 1.什么是Linux

- 多用户、多任务、支持多线程和多CPU的操作系统。
- 它能运行主要的Unix工具软件、应用程序和网络协议。
- 它支持32和64位硬件。
- Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。

### 2.Unix和Linux有什么区别？

- 开源性
- 跨平台
- 可视化界面
- 硬件环境
- 用户群体

### 3.什么是Linux内核？

- 系统内存管理
- 应用程序管理
- 硬件设备管理
- 文件系统管理

### 4.Linux的基本组件是什么？

- 内核，shell和GUI，系统使用程序和应用程序。

### 5.Linux的体系结构

- 两大块

	- 用户空间

		- C库

	- 内核空间：内核空间又包括系统调用接口、内核、平台架构相关的代码

- 为什么Linux体系结构要分为用户空间和内核空间的原因？

	- 现代CPU实现了不同的工作模式，不同模式下CPU可以执行的指令和访问的寄存器不同。
	- Linux从CPU的角度出发，为了保护内核的安全，把系统分成两部分。

		- 系统调用
		- 硬件中断

### 6.BASH和DOS之间的基本区别是什么？

- BASH下,/ character是目录分隔符，\作为转移字符。DOS是\
- DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。

### 7.Linux开机启动过程？

- 主机加电自检，加载BIOS硬件信息
- 读取MBR的引导文件
- 引导Linux内核
- 运行第一个进程init
- 进入相应的运行级别
- 运行终端，输入用户名和密码

### 8.Linux系统缺省的运行级别？

### 9.Linux使用的进程间通信方式?

- 管道、流管道、有名管道
- 信号signal
- 消息队列
- 共享内存
- 信号量
- 套接字socket

### 10.Linux有哪些系统日志文件？

- 比较重要的是/var/log/messages日志文件

### 11.Linux系统安装多个桌面环境有帮助吗？

### 12.什么是交换空间？

- 交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。
- 当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。

### 13.什么是Root账户

- 系统管理员账户，允许你完全控制系统。

### 14.什么是LILO

- 是Linux的引导加载程序。

### 15.什么是BASH？

### 16.什么是CLI？

- 命令行界面

### 17.什么是GUI

- 用户图形界面

### 18.开源的优势是什么？

- 可以添加功能

### 19.GNU项目的重要性是什么？

- 自由学习，分享修改的程序

## 网络和操作系统

## MySQl

### 1.数据库三大范式是什么？

- 第一范式：每个列都不可以再拆分。
- 第二范式：在第一范式基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
- 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。

### 2.MySQL有关权限的表都有哪几个？

- user权限表：记录账号信息，全局级的
- db权限表：记录个个人账号在各个数据库上的操作权限。
- table_priv权限表：记录数据表级的操作权限。
- columns_priv权限表：记录数据列级的操作权限。
- host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。

### 3.MySQL的binlog有几种录入格式？分别有什么区别？

- MySQL的binlog有两种录入格式：

	- 格式1：描述事件的原始格式，这种格式的binlog文件不能被直接读取，只能用于数据备份和恢复。
	- 格式2：描述事件的传输格式，这种格式的binlog文件可以被直接读取，可以用来实现数据的复制和同步。

- 两种格式的区别在于：

	- 格式1的binlog文件只包含事件的原始数据，不包含其他额外的信息，因此这种格式的binlog文件体积比较小。
	- 格式2的binlog文件除了包含事件的原始数据之外，还包含了一些额外的信息，如事件的时间戳、事件的类型和事件的执行结果等。这些额外的信息可以用来帮助我们更好地理解和分析binlog中的事件，但是也会导致binlog文件体积变大。

### 4.Mysql存储引擎MyISAM与InnoDB区别？

- MyISAM和InnoDB是两种不同的MySQL存储引擎。MyISAM是默认的存储引擎，提供快速查询速度和没有事务支持。InnoDB提供了事务支持，能够保证数据的完整性和安全性，但查询速度可能会慢一些。

### 5.MyISAM 索引与 InnoDB 索引的区别？

- MyISAM和InnoDB都是MySQL中的存储引擎，它们都支持索引，但是它们的索引方式有所不同。
- MyISAM的索引是将索引的值和相应的数据行指针存储在索引文件中，这样就可以快速查询出相应的数据行。但是，这种方式有一个缺点，就是如果索引文件发生损坏，整个数据库都将无法使用。
- InnoDB的索引方式不同，它采用了B+树索引，将索引值和相应的数据行指针存储在B+树索引中，这样索引文件和数据文件就是分离的。如果索引文件发生损坏，只需要修复索引文件即可，不会影响整个数据库的使用。

### 6.什么是索引？

- 在InnoDB中，索引是一种特殊的文件，他们包含着对数据表里所有记录的引用指针。
- 索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，已协助快速查询、更新数据库表中数据。索引的实现通常是使用B数及其变种B+树。
- 索引相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

### 7.索引有哪些优缺点？

- 索引的优点

	- 可以打打加快数据的检索速度、
	- 提过索引，提高系统的性能。

- 索引的缺点

	- 时间方面

		- 创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增改删的执行效率。

	- 空间方面

		- 索引占物理空间。

### 8.索引有哪几种类型？

- 主键索引：数据列不允许重复，不允许为NULL，一个表只能有一个主键。
- 唯一索引：

	- 可以通过Alter Table table_name ADD UNIQUE (column):创建唯一索引
	- 可以通过ALTER Table table_name ADD UNIQUE (colum1, colum2)；创建唯一组合索引。

- 普通索引

	- Alter table table_name Add Index index_name （column）
	- alter table table_name Add Index (column1, column2,column3);创建组合索引

- 全文索引

	- ALTER TABLE table_name ADD FULLTEXT （column）；创建全文索引。

### 9.Mysql中有哪几种锁？

- 表级锁：开销小，加锁快；不会出现死锁；粒度大，发生锁冲突的概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

### 10.Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？

- read uncommited：读到未提交数据。
- read commited：脏读，不可重复读。
- repeatable read：可重读。
- serializable:串行事物。

### 11.char和varchar的区别？

- char列长度固定位创建表时声明的长度，长度值范围是1到255
- 当char值被存储时，它们被用空格填充到特定长度，检索char值时需删除尾随空格。

### 12.主键和候选键有什么区别？

- 表格的每一行都由主键唯一标识，一个表只有一个主键。
- 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

### 13.如何在Unix和Mysql时间戳之间进行转换？

- Unix_Timestamp是mysql转linux
- from_unixTime是Unix转mysql

### 14.MyISAM表类型将在哪里存储，并且还提供其存储格式？

- .frm文件，存储表定义
- 数据文件具有“.MYD”扩展名
- 索引文件具有“.MYI”扩展名。

### 15.Mysql里记录货币用什么字段类型好

- DECIMAL

### 16.创建索引时需要注意什么？

- 非空字段
- 取值离散大的字段

	- 不重复的

- 索引字段越小越好

### 17.使用索引查询一定能提高查询的性能吗？为什么

- 索引查询要比全表扫描快。但是也必须注意到他的代价。

	- 索引需要空间来存储，也需要定期维护。每当有记录在表中增减或索引列被修改时，索引本身也会被修改。
	- 这意味着每条记录的INSERT、DELETE、UPDATE将为此多付出4，5次的磁盘IO。
	- 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。
	- 使用索引查询不一定能提高查询性能，索引范围查询适用于两种情况

		- 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
		- 基于非唯一性索引的检索。

### 18.百万级别或以上的数据如何删除？

- 先删除索引。3分钟
- 再删除数据中无用数据。2分钟
- 删除完成后重建创建索引，创建索引也非常快，约10分钟左右。
- 与之前的直接删除绝对是快速很多，更别说玩意删除中断，一切删除会回滚。那是坑了

### 19.什么是最左前缀原则？什么是最左匹配原则

- where子句中使用最频繁的一列放在最左边
- mysql会一直向右匹配知道遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4。如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，a、b、d的顺序可以任意调整。
- = 和 in  可以乱序，比如 a = 1 and b =2 and c =3建立（a,b,c）索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

### 20.什么是聚族索引和非聚族索引，何时使用

### 21.mysql连接器

- mysql -u 用户名 -p 密码
- 用户账号或密码错误，提示Access denied for user

### 22.Mysql查询缓存

- 如果在缓存中，直接返回。通过语句缓存起来，提高查询效率
- 不在缓存中，需要去查询

### 23.mysql分析器

- 如果没有命中查询，就开始执行真正的SQL语句。
- 首先，MySQL会根据你写的SQL语句进行解析，分析器会先做词法分析，你写的SQL就是由多个字符串和空格组成的一条SQl语句，Mysql需要识别出里面的字符串是什么，代表什么
- 然后进行语法分析，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MYsql语法。
- 如果SQL语句不正确，就会提示You have an error in your SQL syntax

### 24.Mysql优化器

- 判断使用哪种索引，使用了何种链接。优化器的作用就是确定效率最高的执行方案。

### 25.Mysql执行器

- Mysql通过分析器知道了你的SQL语句是否合肥，你想要做什么操作，通过优化器就知道。
- 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。对于有索引的表，执行的逻辑也差不多。

### 26.什么是临时表，何时删除临时表？

- MySQL临时表是一种特殊的表，它的数据只能在当前会话中使用，并且在会话结束后会自动删除。临时表通常用于保存查询结果，例如在执行复杂的查询时，您可以将结果保存在临时表中，然后对临时表进行更多的操作。

　　当会话结束，MySQL会自动删除临时表。这意味着如果您关闭MySQL客户端或者终止与MySQL服务器的连接，您的临时表也会被删除。因此，您不需要手动删除临时表。

　　如果您希望保存临时表中的数据，可以将数据导入到另一个表中，例如在创建临时表之前，可以使用CREATE TABLE语句创建一个新表，并将临时表中的数据导入到新表中。

　　总而言之，MySQL临时表是一种非常有用的工具，它可以帮助您更好地管理查询结果，提高查询效率。
- 临时表分为两种：一种是内存临时表，一种是磁盘临时表，什么区别呢？内存临时表使用的是MEMORY存储引擎，而临时表采用的是MylSAM存储引擎。

	- UNION查询
	- 使用TEMPTABLE算法或者是UNION查询中的视图。
	- ORDER BY 和 GROUPBY 的子句不一样时也会产生临时表。
	- DISTINCT查询并且加上ORDER BY时
	- FROM中子查询
	- EXPLAIN查看执行计划结果的Extra列中，如果使用Using Temporary

### 27.谈谈SQL优化的经验

- 查询语句无论是使用哪种判断条件，等于、小于、大于，WHERE左侧的条件查询字段不要使用函数或则表达式。
- 使用EXPLAIN命令优化你的SELECT查询，对于复杂、效率低的sql语句，我们通常是使用explainsql来分析这条sql语句，这样方便我们分析，进行优化。
- 当你的SELECT查询语句只需要使用一条记录时，要使用LIMIT 1.不要直接使用 SELECT*，而应该使用具体需要查询的表字段，因为使用EXPLAIN进行分析时，SELECT使用的是全表烧苗，也就是type = all
- 为每一张表设置一个ID属性
- 避免在WHERE子句中对字段进行NULL
- 判断避免在WHERE中使用！或 > 操作符
- 使用BETWEEN AND 代替 IN
- 为搜索字段创建索引
- 选择正确的存储引擎，InnoDB、MyISAM、MEMORY等。
- 使用LIKE%abc%不会走索引，而使用 LIKE abc%会走索引。
- 对于枚举类型的字段，建议使用ENUM而不是VARCHAR，如性别、星期、类型、类别等。
- 拆分大的DELETE或INSERT语句。
- 选择合适的字段类型，选择标准是尽可能小、尽可能定长、尽可能使用证书。
- 字段设计尽可能使用NOT NULL
- 进行水平切割或者垂直分割

### 28什么叫做外链接？

- 外链接分三种

	- 分别是左外连接（LEFT OUTER JOIN 或 LEFT JOIN）右外连接（ RIGHT OUTER JOIN 或RIC GHT JOIN）全外连接（FULL OUTER JOIN 或 FULLJOIN）

- 左外连接：又称为做链接，这种连接方式会显示左表不符合条件的数据行，右边不符合条件的数据行直接显示NULL
- 右外连接：也被称为右连接，他与左连接相对，这种连接方式会显示右表不符合条件的数据行，左表不符合条件的数据直接显示NULL

### 29.什么叫内链接？

### 30.union和union all 时需要注意什么？

- 通过union连接的SQL分别单独去除的列数必须相同。
- 使用union时，多个相等的行将会被合并，由于合并比较好使，一般不直接使用union进行合并，而是通常采用union all 进行合并。

### 31.MyISAM存储引擎的特点

- MyISAM的并发性比较差，使用场景比较少

	- 不支持事务、不支持外键操作、粒度是表级锁，并发性能差、存储三个文件frm数据表定义、mym存储数据、myi存储索引

- 支持全局索引（Full-Text）、B-Tree索引、R-Tree索引
- 数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难以恢复
- 增删改查性能方面：SELECT性能较高，使用与查询较多的情况

### 32.InnoDB存储引擎的特点

- 支持事务操作，具有事务ACID隔离特性，默认的隔离级别是可重复度、通过MVCC（并发版本控制）来实现的。能够解决脏读和不可重复读的问题。InnoDB支持外键操作。
- InnoDB默认的锁粒度行级锁，并发性能比较好，会发生死锁的情况。
- 和MyISAM一样的是，InnoDB存储引擎也有frm文件存储表结构定义，但是不同的是，InnoDB的表数据与索引数据是存储在一起的，都位于B+树的叶子结点上，而MyISAM的表数据和索引数据是分开的。
- InnoDB有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。
- InnoDB和MyISAM支持的索引类型相同，但具体实现因为文件结构的不同有很大差异
- 增删改查性能方面，如果执行大量的增删改查操作，推荐使用InnoDB存储引擎，它在删除操作室是对行删除，不会重建表。

## 容器技术

### 1.为什么需要DevOps?

- 增加软件部署的频率
- 降低新发布版本的失败率
- 缩短修复缺陷的交付时间
- 加快解决版本冲突的问题
- DevOps满足所有这些需求且帮助公司高质量完成软件无缝交付的目标

### 2.Docker是什么？

- 包含代码，运行时，系统工具，系统库等。
- Namespace

	- 相互隔离
	- 一种隔离机制，目的是隔离容器与宿主机、进程间不能访问彼此资源。
	- 第一个是可以充分利用系统的资源，也就是一台机器可以运行多个容器。
	- 第二个是保障安全性。防止互相访问彼此的资源。
	- NameSpace是Linux两大技术之一，目的就是为了解决资源隔离

		- PID NameSpace负责不同进程间的隔离
		- NetWork NameSpace 负责网络环境的隔离
		- Mount NameSpace管理文件系统的隔离

- CGroup

	- CPU子系统，用来限制一个控制组
	- memory限制内存
	- pids限制最多进程数
	- cpuset限制进程可以在哪几个CPU上运行

### 3.DevOps有哪些优势？

- 技术优势

	- 持续的软件交付能力
	- 修复问题变得简单
	- 更快得解决问题

- 商业优势

	- 更快交付的特性
	- 更稳定的操作系统环境
	- 更多时间可用于创造价值

### 4.CI服务有什么用途？

### 5.如何使用Docker技术创建与环境无关的容器系统？

- 存储卷(Volumes)
- 环境变量(Environment variable)注入
- 只读(Read-only)文件系统

### 6.Dockerfile配置文件中的COPY和ADD指令有什么不同？

- 功能相似，推荐copy
- COpy更容易懂
- 有必要使用ADD指令的最好例子就是在本地自动解压归档文件到容器中的情况。如ADD rootfs.tar.xz

### 7.Docker映像(image)是什么？

- Docker image，Docker容器的源。
- 映像(Images)通过Docker build命令创建，当run映像时，它启动成一个容器（container）进程。
- 做好的映像由于可能非常庞大，常注册存储在诸如registry.hub.docker.com这样的公共平台上。
- 映像常被分层设计，每层可单独成为一个小映像，由多层小映像再构成大映像，这样碎片化的设计为了使映像再互联网上共享时，最小化传输数据需求。

### 8.Docker容器（container）是什么？

- 是包含其所有运行依赖环境，但与其它容器共享操作系统内核的应用，它运行在独立的主机·
- 可运行在任何配置的计算机上。

### 9.Docker中心（hub）什么概念？

- Docker hub是云基础的Docker注册服务平台，它运行用户进行访问Docker中心资源库，创建自己的Dokcer映像并测试，推送并存储创建好的docker映像，连接Docker云屏体验将已创建好的指定Docker映像部署到本地主机等任务。
- 提供一个查找发现Docker映像，发布Docker映像及控制变化升级的资源中心，成为用户组或团队协作开发中保证自动化开发流程的有效技术途径。

### 10.在任意给定时间点指出一个Dokcer容器可能存在的运行阶段?

- 运行中
- 已暂停
- 重启中
- 已退出

### 11.有什么方法确定一个Docker容器运行状态?

- docker ps -a

### 12.在Dockerfile配置文件中最常用的指令有哪些？

- FROM：镜像来源
- LABEL：组织项目映像、模块、许可等。
- RUN：执行命令并创建一个新层，用于映像层中添加功能层，也许最来的层会依赖他。
- CMD：执行容器提供默认值。

### 13.什么类型的应用（无状态性或有状态性）更适合Docker容器技术？

- 无状态应用是指应用不需要保存状态信息，因此在执行过程中不需要访问本地存储。这种应用可以通过在容器中运行多个实例来扩展其处理能力，并且容器可以轻松地在多个服务器上迁移。
- 例如，Web 应用程序通常是无状态的，因为它们只需要处理请求并返回响应，而不需要保存任何状态信息。这种应用程序非常适合使用 Docker 容器来进行部署和扩展。
- 相反，有状态应用程序需要在执行过程中访问本地存储来保存状态信息，这种应用程序不太适合使用 Docker 容器。例如，一个用于管理大量客户信息的 CRM 系统就是一个有状态应用程序，它需要保存客户信息，并在处理请求时使用这些信息。在这种情况下，使用 Docker 容器可能会导致状态信息丢失或不一致。

### 14.解释基本Docker应用流程

- Dockerfile

	- registry注册中心发布

### 15.Docker Image 和 Docker Layer层有什么不同？

- Image是只读层创建出来的
- Layer层是完成一条配置指令。RUN COPY FROM

### 16.虚拟化技术是什么？

- 全模拟
- 半虚拟
- 基于容器的虚拟化

### 17.虚拟管理层(程序)是什么？

- 虚拟管理层(Virtual Management Layer)是一种软件，它可以模拟管理层的功能，帮助组织更好地管理其业务流程和资源。这种软件通常用于帮助组织提高工作效率和降低成本，并且可以在不同的部门之间共享信息和资源。例如，一个组织可以使用虚拟管理层软件来管理它的客户关系、供应链、人力资源和财务流程。

### 18.Docker群（Swarm）是什么？

- Docker Swarm 是 Docker 的一项服务，可用于在多台机器上部署和管理 Docker 容器。它可以将多个物理或虚拟机器组织成一个单独的虚拟集群，并提供一个统一的接口来管理这些机器上的容器。通过使用 Docker Swarm，组织可以更轻松地部署分布式应用程序，并实现负载平衡、容错和自动伸缩。

### 19.在使用Docker技术的产品找那个如何监控其运行?

- docker stats: 通过id获取其运行统计信息，可获得容器对CPU，内存使用情况等的统计信息，类似Linux系统中的top命令。
- 在使用 Docker 技术的产品中，通常可以使用 Docker 的内置监控工具来监控容器的运行情况。这些工具包括 docker stats 命令，它可以实时报告容器的 CPU、内存和网络使用情况；docker events 命令，它可以报告容器的启动、停止和错误事件；以及 Docker 的日志系统，可以收集容器内部的日志信息。

### 20.什么是孤儿卷及如何删除它？

- 孤儿卷式未与任何容器关联的卷。在Docker v1.9之前删除它会有很大的问题。

### 21.什么是半虚拟化？

- 半虚拟化是一种虚拟化技术，它在物理主机上运行多个操作系统，但每个操作系统都会共享一部分硬件资源。这种技术与完全虚拟化的区别在于，完全虚拟化的操作系统都是独立的，它们并不共享任何硬件资源。
- 半虚拟化的优点在于它可以提供较高的性能，因为操作系统可以直接访问硬件资源，而不需要经过虚拟化层的抽象和转换。但其缺点在于它不能完全隔离操作系统，因此可能会存在安全问题。

### 22.Docker技术与虚拟机技术有何不同？

- 与虚拟机不同，docker无需启动操作系统内核。运行快
- 容器化技术很少或几乎不给主机系统增加负载。
- 容器化不需要管理层软件
- 共享主机操作系统上进程调度，从而节省了额外的资源的需求。
- 与虚拟机image相比，容器映像较小，因此，容器映像易于分发。
- 容器由Cgroups实现资源分配。

## 缓存

## 消息队列

## 分布式

## K8s

### 1.Kubernetes有哪些核心组件

- Kubernetes 是一个开源的容器编排系统，它能够自动部署、扩展和管理容器化应用。Kubernetes 的核心组件包括：
- kube-apiserver：提供了一个 RESTful 接口，用于执行操作，如创建、更新和删除应用程序的部署。
- etcd：用于存储 Kubernetes 集群的配置信息、服务发现和元数据。
- kube-scheduler：负责调度容器在集群中的运行位置。
- kube-controller-manager：负责管理 Kubernetes 集群中的各种控制器，如 ReplicaSet 控制器和 Deployment 控制器。
- kubelet：运行在集群中的每个节点上，负责管理容器的生命周期。
- kube-proxy：负责为集群中的应用程序提供网络访问。

*XMind - Trial Version*