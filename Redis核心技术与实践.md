# Redis核心技术与实践

## 01基本架构：一个键值数据库包含什么？

### 系统观

- redis经常被用于缓存、秒杀、分布式锁等场景的重要基础。
- 可以存哪些数据？

	- KV，string、哈希表、列表、集合等。Redis能够在实际业务场景中得到广泛应用个，多得支持多样化类型的value

- 可以对数据做什么操作？

	- PUT、GET、DELETE
	- 有些健值数据库的新写/更新操作叫SET
	- 基本集合：SCAN等

- 健值对保持在内存还是外存？

	- 内存短电，外存磁盘慢。

- 如何设计，考虑健值数据库的主要应用场景？

	- 一个健值数据库包括了访问框架、索引模块、操作模块和存储模块。

- 采用什么访问模式？

	- 通过函数库调用的方式供外部使用。
	- 通过网络框架以Socket通信的形式对外提供健值对操作。

- 发送给健值数据库流程

	- 网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？

		- 网络链接

	- 索引的作用是让健值数据库根据key找到相应的value的存储位置，进而执行操作。

- 不同操作的具体逻辑是怎么样的？

	- 对GET/SCAN操作而言，此时根据value的存储位置返回value值即可。

- 如何实现重启后快速提供服务？

	- 内存分配器glibc的malloc和free。
	- 分配器是健值数据库中的一个关键因素。对于以内存存储为主的Redis而言，这点尤为重要。redis的内存分配器提供了多种选择，分配效率也不一样。
	- 对健值对，落盘保存，数据更加可靠。
	- 周期性保存到文件只能够，避免频繁写入导致性能影响。

- SimpleKV演进到Reids

	- Redis主要通过网络框架进行访问，而不再是动态库了。
	- Redis数据模型中的value类型很丰富，因此也带来了更多的操作借口。
	- 日志（AOF）和快照（RDB）
	- 提供可靠性集群和高可扩展集群。

## 02数据结构：快速的Redis有哪些慢操作？

### 内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。另一方面，这要归功与它的数据结构。键值对按一定的数据结构来组织的，操作键值对最终是通过对数组结构进行增删改查。

### 底层数据结构一共有6种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。

- List、Hash、Set、Sorted Set

### 键值用什么结构组织？

- 哈希桶
- 大量数据进入，哈希表的冲突问题和rehash可能带来的操作阻塞

### 为什么哈希表操作变慢了？

- 同时落在一个桶里面了。
- 哈希冲突链上的元素只能通过指针逐个查找再操作。
- Redis对哈希表做rehash操作。也增加哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶的中的冲突。
- rehash

	- 1.给哈希表2分配更大的空间，当前哈希表1大小的两倍
	- 2.把哈希表1中的数据重新映射到哈希表2.拷贝
	- 3.释放哈希表1的空间

- 如果大量的数据拷贝，会导致线程阻塞。

### 渐进式rehash

- 分次拷贝。避免了好使操作，保证了数据的快速访问。

### 集合数据操作效率

- 哈希表实现的集合，要比使用hash表实现的集合访问效率更高。其次，操作效率和这些操作本身的执行特点有关，比如读写一个元素要比读写所有元素的效率要高。

### 有哪些底层数据结构？

- 整数集合、hash表、跳表、双向链表、压缩列表
- 数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有3个字段，分别是列表长度、列表尾的偏移量和列表中的entry个数；压缩列表在表尾海域zlend，表示列表结束。
- 跳表

	- 增加多级索引，通过索引位置的几个跳转，实现数据的快速定位。
	- 从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素1作为一级索引，从第三、第四个元素中抽取元素11作为一级索引。只需要4次查找就能定位到元素33了。
	- 查找过程是多级索引上跳来跳去，最火定位到元素。跳表查找复杂度就是O（logn）

### 不同操作的复杂度

- 单元素操作是基础

	- 每一种集合类型对单个数据实现的增删改查操作。Hash类型的HGET、HSET和HDEL。

- 范围操作非常耗时

	- 范围操作，是指集合类型中的遍历操作，可以遍历集合中的所有数据。
	- 尽量避免，非常耗时。O（n）

- 统计操作通常高效

	- 集合类型对集合中所有元素个数的记录
	- 只有O（1）

- 例外情况至于哦几个

	- 压缩列表和双向链表都会记录表头和表尾的偏移量。

### 小结

- 支持集合类型实现，全局哈希表。双向链表，跳表。
- O（1）复杂度的哈希表被广泛使用，包括String、Hash和Set，它们的操作复杂度基本由hash表决定，另一方面，Sorted Set也采用了O（logN）复杂度的跳表。
- 遍历采用其他命令来代替，SCAN可以避免全集合遍历操作。
- 因地制宜使用List类型。POP/PUSH销量很高，那么在FIFO队列场景，而不是作为一个可以随机读写的集合。

## 03高性能IO模型：为什么单线程Redis能那么快？

### 搞清楚一个事实

- Redis是单线程，主要是Redis的网络IO和键值对读写是由一个线程完成的，这也是Redis对外提供键值对读写是由一个线程来完成的，这也是redis对外提供键值存储服务的主要流程。
- 但Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

### Redis为什么用单线程？

- 多线程的开销

	- 资源分配下，进而提升系统能够同时处理的请求数，即吞吐率。
	- 我们刚开始增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增加迟缓了，甚至下降。

		- 为什么会出现这种情况呢？系统中通常会存在被多线程同时访问的共享资源，比如共享一个数据结构。
		- 例如：List入队出队操作，为了保持队列长度的正确性，需要串行执行。这就是多线程编程模式面临的共享资源的并发访问控制的问题。

	- 并发访问控制的一个难点：即使增加线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行。吞吐率并没有增加。

### 单线程Redis为什么那么快？

- 思考一个问题

	- 单线程的处理能力要比多线程差很多，但是为什么单线程模型达到每秒数十万级别的处理能力？

- Redis大部分操作都是在内存上完成的，再加上高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。另外，Redis采用多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

### 基本IO模型与阻塞点

- Get请求用例

	- 需要监听客户端请求（blind/listen），和客户端建立连接（accept），从socket中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向socket中写回数据（send）
	- 既然Redis是单线程，最基本的一种实现是在一个线程中依次执行。

- 在这里的网络IO操作中，有潜在的阻塞点，分别是accept（）和recv（）。从一个客户端读取数据时，如果数据一直没有到达，Redis也会一直阻塞在recv（）。
- 上面的阻塞，会导致效率低，但是socket网络模型本身支持非阻塞模式。

### 非阻塞模式

- Socket网络模型的非阻塞模式设置，主要体现在三个关键函数调用上。

	- 在socket模型中，不同操作返回不同的套接字类型。socket（）方法会繁华主动套接字，然后调用listen方法，将主动套接字转化为监听套接字。调用accept方法接收到达的客户端链接。
	- 也就是说，非阻塞IO调用accept但一直未有连接请求时，Redis线程返回其他操作，而不用一直等待。

### 基于多路复用的高性能IO模型

- Linux中有select/epoll机制。该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给Redis线程处理，这就实现了Redis县城多个IO流的效果。
- redis采用epoll机制，让内核监听这些套接字。此时，Reids不会阻塞在请求的处理上。Redis可以同时和多个客户端连接并处理请求，从而提升并发性。
- 为了线程到达时能通知Redis线程，select/epoll提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。这就是实现了基于事件的回调。因为Redis一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis的响应性能。
- Redis分别对这两个事件注册accept和get回调函数。内核就会回调Redis相应的accept和get函数进行处理。

*XMind - Trial Version*